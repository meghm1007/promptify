"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/utils/messaging-helpers.ts
function sendMessageToContentScript(tabId, message) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      message.target = "contentScriptMellowtel";
      chrome.tabs.sendMessage(tabId, message, function(response) {
        resolve(response);
      });
    });
  });
}
function sendMessageToBackground(message) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage(message, (response) => {
        resolve(response);
      });
    });
  });
}
var init_messaging_helpers = __esm({
  "src/utils/messaging-helpers.ts"() {
    "use strict";
  }
});

// src/utils/storage-helpers.ts
function getLocalStorage(key) {
  return new Promise((resolve) => {
    shouldDelegateStorage().then((delegate) => {
      if (delegate) {
        sendMessageToBackground({ intent: "getLocalStorage", key }).then(
          (response) => {
            resolve(response);
          }
        );
      } else {
        chrome.storage.local.get(key, function(result) {
          resolve(result);
        });
      }
    });
  });
}
function setLocalStorage(key, value) {
  return new Promise((resolve) => {
    shouldDelegateStorage().then((delegate) => {
      if (delegate) {
        sendMessageToBackground({
          intent: "setLocalStorage",
          key,
          value
        }).then((response) => {
          resolve(response);
        });
      } else {
        chrome.storage.local.set({ [key]: value }, function() {
          resolve(true);
        });
      }
    });
  });
}
function deleteLocalStorage(keys) {
  return new Promise((resolve) => {
    shouldDelegateStorage().then((delegate) => {
      if (delegate) {
        sendMessageToBackground({
          intent: "deleteLocalStorage",
          keys: JSON.stringify(keys)
        }).then((response) => {
          resolve(response);
        });
      } else {
        chrome.storage.local.remove(keys, function() {
          resolve(true);
        });
      }
    });
  });
}
function shouldDelegateStorage() {
  return new Promise((resolve) => {
    try {
      chrome.storage.local.get(null, () => {
        if (chrome.runtime.lastError) {
          resolve(true);
        } else {
          resolve(false);
        }
      });
    } catch (error) {
      resolve(true);
    }
  });
}
var init_storage_helpers = __esm({
  "src/utils/storage-helpers.ts"() {
    "use strict";
    init_messaging_helpers();
  }
});

// src/utils/identity-helpers.ts
function getOrGenerateIdentifier(configuration_key) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      getLocalStorage("mllwtl_identifier").then((result) => {
        if (result.mllwtl_identifier && result.mllwtl_identifier.startsWith(`mllwtl_${configuration_key}`)) {
          resolve(result.mllwtl_identifier);
        } else if (result.mllwtl_identifier && result.mllwtl_identifier.startsWith(`mllwtl_`)) {
          generateIdentifier(
            configuration_key,
            true,
            result.mllwtl_identifier
          ).then((identifier) => {
            resolve(identifier);
          });
        } else {
          generateIdentifier(configuration_key).then((identifier) => {
            resolve(identifier);
          });
        }
      });
    });
  });
}
function generateIdentifier(configuration_key, just_update_key = false, previous_identifier = "") {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      const random_string = just_update_key ? previous_identifier.split("_")[1] : generateRandomString(10);
      const identifier = `mllwtl_${configuration_key}_${random_string}`;
      setLocalStorage("mllwtl_identifier", identifier).then((result) => {
        resolve(identifier);
      });
    });
  });
}
function generateRandomString(length) {
  return Math.random().toString(36).substring(2, length + 2);
}
function getIdentifier() {
  return new Promise((resolve) => {
    getLocalStorage("mllwtl_identifier").then((result) => {
      if (result.mllwtl_identifier) {
        resolve(result.mllwtl_identifier);
      } else {
        setTimeout(() => {
          getIdentifier().then((identifier) => {
            resolve(identifier);
          });
        }, 200);
      }
    });
  });
}
var init_identity_helpers = __esm({
  "src/utils/identity-helpers.ts"() {
    "use strict";
    init_storage_helpers();
  }
});

// src/logger/logger.ts
var Logger;
var init_logger = __esm({
  "src/logger/logger.ts"() {
    "use strict";
    Logger = class {
      static info(message, ...optionalParams) {
        if (!this.disableLogs) {
          console.info(message, ...optionalParams);
        }
      }
      static log(message, ...optionalParams) {
        if (!this.disableLogs) {
          console.log(message, ...optionalParams);
        }
      }
      static warn(message, ...optionalParams) {
        if (!this.disableLogs) {
          console.warn(message, ...optionalParams);
        }
      }
      static error(message, ...optionalParams) {
        if (!this.disableLogs) {
          console.error(message, ...optionalParams);
        }
      }
    };
    Logger.disableLogs = true;
  }
});

// src/constants.ts
var MELLOWTEL_VERSION, MAX_PARALLEL_EXECUTIONS, MAX_QUEUE_SIZE, LIFESPAN_IFRAME, DATA_ID_IFRAME, RULE_ID_XFRAME, RULE_ID_CONTENT_DISPOSITION, RULE_ID_CONTENT_TYPE, RULE_ID_VALUE_TO_MODIFY_CONTENT_TYPE_TO;
var init_constants = __esm({
  "src/constants.ts"() {
    "use strict";
    MELLOWTEL_VERSION = "1.1.6";
    MAX_PARALLEL_EXECUTIONS = 4;
    MAX_QUEUE_SIZE = 12;
    LIFESPAN_IFRAME = 1e3 * 60 * 1.5;
    DATA_ID_IFRAME = "data-mllwtl-frame-crwl-ml";
    RULE_ID_XFRAME = 80045;
    RULE_ID_CONTENT_DISPOSITION = 80046;
    RULE_ID_CONTENT_TYPE = 80047;
    RULE_ID_VALUE_TO_MODIFY_CONTENT_TYPE_TO = 80048;
  }
});

// src/content-script/queue-crawl.ts
function insertInQueue(dataPacket) {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      getLocalStorage("queue").then((result) => {
        if (result === void 0 || !result.hasOwnProperty("queue"))
          result = { queue: [] };
        let queue = result.queue;
        if (queue.length > MAX_QUEUE_SIZE) {
          Logger.log("[\u{1F310}] : queue is full. Ignoring this packet");
          resolve(false);
        } else {
          queue.push(dataPacket);
          setLocalStorage("queue", queue).then(() => {
            resolve(true);
          });
        }
      });
    });
  });
}
function getLastFromQueue() {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      getLocalStorage("queue").then((result) => {
        if (result === void 0 || !result.hasOwnProperty("queue"))
          result = { queue: [] };
        let queue = result.queue;
        if (queue.length === 0)
          return resolve({
            url: "",
            recordID: "0123",
            eventData: {},
            waitForElement: "none",
            shouldSandbox: false,
            sandBoxAttributes: ""
          });
        let last = queue.shift();
        setLocalStorage("queue", queue).then(() => {
          resolve(last);
        });
      });
    });
  });
}
var init_queue_crawl = __esm({
  "src/content-script/queue-crawl.ts"() {
    "use strict";
    init_storage_helpers();
    init_logger();
    init_constants();
  }
});

// src/utils/dnr-helpers.ts
function disableXFrameHeaders(hostname, skipHeaders) {
  return new Promise(function(res) {
    if (skipHeaders) {
      res(false);
    } else {
      let ruleId = getRuleIdFromHostname(hostname);
      shouldDelegateDNR().then((delegate) => {
        if (delegate) {
          sendMessageToBackground({
            intent: "disableXFrameHeaders",
            hostname,
            skipHeaders
          }).then(() => {
            res(true);
          });
        } else {
          chrome.declarativeNetRequest.updateSessionRules({
            removeRuleIds: [ruleId],
            addRules: [
              {
                id: ruleId,
                priority: 1,
                action: {
                  type: "modifyHeaders",
                  responseHeaders: [
                    {
                      header: "x-frame-options",
                      operation: "remove"
                    },
                    {
                      header: "content-security-policy",
                      operation: "remove"
                    },
                    {
                      header: "X-Frame-Options",
                      operation: "remove"
                    },
                    {
                      header: "Content-Security-Policy",
                      operation: "remove"
                    },
                    {
                      header: "Frame-Options",
                      operation: "remove"
                    }
                  ]
                },
                condition: {
                  resourceTypes: ["sub_frame"],
                  urlFilter: "*://*/*"
                  // `*${hostname}*`, --> specific filter disabled because
                  // there are internal redirects that need to be handled.
                  // Need to find a way to handle redirects and disable headers
                  // for all of them (while leaving them on for other sites).
                }
              }
            ]
          });
          res(true);
        }
      });
    }
  });
}
function enableXFrameHeaders(hostname) {
  return new Promise(function(res) {
    let ruleId = getRuleIdFromHostname(hostname);
    shouldDelegateDNR().then((delegate) => {
      if (delegate) {
        sendMessageToBackground({
          intent: "enableXFrameHeaders",
          hostname
        }).then(() => {
          res(true);
        });
      } else {
        chrome.declarativeNetRequest.updateSessionRules({
          removeRuleIds: [ruleId]
        });
        res(true);
      }
    });
  });
}
function getRuleIdFromHostname(hostname) {
  return RULE_ID_XFRAME;
}
function shouldDelegateDNR() {
  return new Promise((resolve) => {
    try {
      chrome.declarativeNetRequest.getDynamicRules((rules) => {
        if (chrome.runtime.lastError) {
          resolve(true);
        } else {
          resolve(false);
        }
      });
    } catch (error) {
      resolve(true);
    }
  });
}
var init_dnr_helpers = __esm({
  "src/utils/dnr-helpers.ts"() {
    "use strict";
    init_messaging_helpers();
    init_constants();
  }
});

// src/utils/utils.ts
function getFrameCount() {
  return document.querySelectorAll(`[data-id=${DATA_ID_IFRAME}]`).length;
}
var init_utils = __esm({
  "src/utils/utils.ts"() {
    "use strict";
    init_constants();
  }
});

// src/utils/iframe-helpers.ts
function injectHiddenIFrame(url, id, onload = function() {
}, width = "500px", data_id = "", should_sandbox = false, sandbox_attributes = "") {
  let iframe = document.createElement("iframe");
  iframe.id = id;
  iframe.credentialless = true;
  iframe.style.width = width;
  iframe.style.height = "200px";
  iframe.style.display = "none";
  if (should_sandbox) {
    iframe.setAttribute("sandbox", "");
    if (sandbox_attributes !== "")
      iframe.setAttribute("sandbox", sandbox_attributes);
  }
  if (data_id !== "")
    iframe.setAttribute("data-id", data_id);
  iframe.src = url;
  iframe.onload = onload;
  document.body.prepend(iframe);
}
function inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}
var init_iframe_helpers = __esm({
  "src/utils/iframe-helpers.ts"() {
    "use strict";
  }
});

// src/utils/triggers-download-helpers.ts
function sendToBackgroundToSeeIfTriggersDownload(url, triggersDownload) {
  return __async(this, null, function* () {
    return new Promise(function(res) {
      sendMessageToBackground({
        intent: "seeIfTriggersDownload",
        url,
        triggersDownload
      }).then((response) => {
        res(response);
      });
    });
  });
}
function seeIfTriggersDownload(url, triggersDownload) {
  return __async(this, null, function* () {
    return new Promise(function(res) {
      if (!triggersDownload) {
        res("done");
      } else {
        let rulesToApply = [];
        fetchAndProcessHeaders(url).then(function(result) {
          Logger.log("fetchAndProcessHeaders =>", result);
          if (result.error) {
            res("error");
          } else {
            if ("removeContentDisposition" in result && result.removeContentDisposition) {
              rulesToApply.push({
                id: RULE_ID_CONTENT_DISPOSITION,
                priority: 2,
                action: {
                  type: "modifyHeaders",
                  responseHeaders: [
                    {
                      header: "content-disposition",
                      operation: "remove"
                    }
                  ]
                },
                condition: {
                  resourceTypes: ["sub_frame"],
                  urlFilter: "*://*/*"
                }
              });
            }
            if ("modifyContentType" in result && result.modifyContentType) {
              rulesToApply.push({
                id: RULE_ID_CONTENT_TYPE,
                priority: 2,
                action: {
                  type: "modifyHeaders",
                  responseHeaders: [
                    {
                      header: "content-type",
                      operation: "remove"
                    }
                  ]
                },
                condition: {
                  resourceTypes: ["sub_frame"],
                  urlFilter: "*://*/*"
                }
              });
            }
            if ("valueToModifyContentTypeTo" in result && result.valueToModifyContentTypeTo) {
              rulesToApply.push({
                id: RULE_ID_VALUE_TO_MODIFY_CONTENT_TYPE_TO,
                priority: 2,
                action: {
                  type: "modifyHeaders",
                  responseHeaders: [
                    {
                      header: "content-type",
                      operation: "set",
                      value: result.valueToModifyContentTypeTo
                    }
                  ]
                },
                condition: {
                  resourceTypes: ["sub_frame"],
                  urlFilter: "*://*/*"
                }
              });
            }
            chrome.declarativeNetRequest.updateSessionRules({
              removeRuleIds: [
                RULE_ID_CONTENT_DISPOSITION,
                RULE_ID_CONTENT_TYPE,
                RULE_ID_VALUE_TO_MODIFY_CONTENT_TYPE_TO
              ],
              addRules: rulesToApply
            });
            res("done");
          }
        });
      }
    });
  });
}
function resetTriggersDownload() {
  return __async(this, null, function* () {
    return new Promise(function(res) {
      shouldDelegateDNR().then((delegate) => {
        if (delegate) {
          sendMessageToBackground({
            intent: "resetTriggersDownload"
          }).then(() => {
            res("done");
          });
        } else {
          chrome.declarativeNetRequest.updateSessionRules({
            removeRuleIds: [
              RULE_ID_CONTENT_DISPOSITION,
              RULE_ID_CONTENT_TYPE,
              RULE_ID_VALUE_TO_MODIFY_CONTENT_TYPE_TO
            ]
          });
          res("done");
        }
      });
    });
  });
}
function fetchAndProcessHeaders(url) {
  return fetch(url).then((response) => {
    if (!response.ok) {
      return { error: true };
    }
    const result = processHeaders(response, response.url);
    return __spreadValues(__spreadValues({}, result), {
      error: false
    });
  }).catch((error) => {
    Logger.error("Fetch error:", error);
    return { error: true };
  });
}
function processHeaders(response, url) {
  let headers = [];
  response.headers.forEach((value, name) => {
    headers.push({ name, value });
  });
  let removeContentDisposition = false;
  let modifyContentType = false;
  let valueToModifyContentTypeTo = "";
  for (let i = 0; i < headers.length; i++) {
    if (headers[i].name.toLowerCase() === "content-disposition" && headers[i].value.indexOf("attachment") === 0) {
      removeContentDisposition = true;
      headers.splice(i, 1);
      break;
    }
  }
  for (let j = 0; j < headers.length; j++) {
    if (headers[j].name.toLowerCase() === "content-type") {
      if (headers[j].value === "application/octet-stream" || headers[j].value === "application/x-download") {
        let fileType = url.substring(url.lastIndexOf(".") + 1).toLowerCase();
        let skip = [
          "exe",
          "dmg",
          "deb",
          "rpm",
          "apk",
          "zip",
          "rar",
          "7z",
          "gz",
          "xz"
        ];
        let fixApplication = ["pdf", "json", "xml", "ogg"];
        let fixImage = ["gif", "jpg", "jpeg", "png", "tiff"];
        if (!skip.includes(fileType)) {
          modifyContentType = true;
          if (fixApplication.includes(fileType)) {
            valueToModifyContentTypeTo = "application/" + fileType;
          } else if (fixImage.includes(fileType)) {
            valueToModifyContentTypeTo = "image/" + fileType;
          } else {
            valueToModifyContentTypeTo = "text/plain";
          }
          headers[j].value = valueToModifyContentTypeTo;
        }
      }
      break;
    }
  }
  return {
    removeContentDisposition,
    modifyContentType,
    valueToModifyContentTypeTo
  };
}
var init_triggers_download_helpers = __esm({
  "src/utils/triggers-download-helpers.ts"() {
    "use strict";
    init_logger();
    init_constants();
    init_dnr_helpers();
    init_messaging_helpers();
  }
});

// src/content-script/execute-crawl.ts
function preProcessCrawl(dataPacket) {
  return __async(this, null, function* () {
    let type_event = dataPacket.hasOwnProperty("type_event") ? dataPacket.type_event : "crawl";
    if (type_event === "heartbeat")
      return;
    Logger.log("\u{1F4CB} Data Packet \u{1F4CB}");
    Logger.log(dataPacket);
    Logger.log("\u{1F4CB} ----------- \u{1F4CB}");
    let url = dataPacket.url;
    let recordID = dataPacket.recordID;
    let waitBeforeScraping = parseInt(dataPacket.waitBeforeScraping) * 1e3;
    let saveHtml = dataPacket.saveHtml.toString().toLowerCase() === "true";
    let saveMarkdown = dataPacket.saveMarkdown.toString().toLowerCase() === "true";
    let removeCSSselectors = dataPacket.removeCSSselectors;
    let classNamesToBeRemoved = JSON.parse(
      dataPacket.classNamesToBeRemoved
    );
    let fastLane = dataPacket.hasOwnProperty("fastLane") ? dataPacket.fastLane.toString().toLowerCase() === "true" : false;
    let waitForElement = dataPacket.hasOwnProperty("waitForElement") ? dataPacket.waitForElement : "none";
    let waitForElementTime = dataPacket.hasOwnProperty(
      "waitForElementTime"
    ) ? parseInt(dataPacket.waitForElementTime) : 0;
    let removeImages = dataPacket.hasOwnProperty("removeImages") ? dataPacket.removeImages.toString().toLowerCase() === "true" : false;
    let htmlTransformer = dataPacket.hasOwnProperty("htmlTransformer") ? dataPacket.htmlTransformer : "none";
    let isPDF = url.includes("?") ? url.split("?")[0].endsWith(".pdf") : url.endsWith(".pdf");
    let saveText = dataPacket.saveText.toString().toLowerCase() === "true";
    let orgId = dataPacket.hasOwnProperty("orgId") ? dataPacket.orgId : "";
    let shouldSandbox = dataPacket.hasOwnProperty("shouldDisableJS") ? dataPacket.shouldDisableJS.toString().toLowerCase() === "true" : false;
    let sandBoxAttributes = dataPacket.hasOwnProperty("sandBoxAttributes") ? dataPacket.sandBoxAttributes : "";
    let triggersDownload = dataPacket.hasOwnProperty("triggersDownload") ? dataPacket.triggersDownload.toString().toLowerCase() === "true" : false;
    let skipHeaders = dataPacket.hasOwnProperty("skipHeaders") ? dataPacket.skipHeaders.toString().toLowerCase() === "true" : false;
    crawlP2P(
      url,
      recordID,
      waitBeforeScraping,
      saveHtml,
      saveMarkdown,
      removeCSSselectors,
      classNamesToBeRemoved,
      fastLane,
      waitForElement,
      waitForElementTime,
      removeImages,
      htmlTransformer,
      isPDF,
      saveText,
      orgId,
      shouldSandbox,
      sandBoxAttributes,
      triggersDownload,
      skipHeaders
    );
  });
}
function preProcessUrl(url, recordID) {
  if (url.startsWith("http://"))
    url = url.replace("http://", "https://");
  let urlObj = new URL(url);
  let params = new URLSearchParams(urlObj.search);
  params.append("mellowtel-p2p", "true");
  params.append("should-crawl", "true");
  params.append("record-id", recordID);
  urlObj.search = params.toString();
  let hostname = urlObj.hostname;
  url = urlObj.toString();
  return [url, hostname];
}
function crawlP2P(url, recordID, waitBeforeScraping, saveHtml, saveMarkdown, removeCSSselectors, classNamesToBeRemoved, fastLane, waitForElement, waitForElementTime, removeImages, htmlTransformer, isPDF, saveText, orgId, shouldSandbox, sandBoxAttributes, triggersDownload, skipHeaders) {
  let [url_to_crawl, hostname] = preProcessUrl(url, recordID);
  Logger.log("[\u{1F310} crawlP2P] : url_to_crawl => " + url_to_crawl);
  Logger.log("[\u{1F310} crawlP2P] : hostname => " + hostname);
  Promise.all([
    disableXFrameHeaders(hostname, skipHeaders),
    sendToBackgroundToSeeIfTriggersDownload(url, triggersDownload)
  ]).then(() => __async(this, null, function* () {
    let eventData = {
      isMellowtelCrawl: true,
      fastLane,
      url_to_crawl,
      recordID,
      removeCSSselectors,
      classNamesToBeRemoved,
      saveHtml,
      saveMarkdown,
      waitBeforeScraping,
      waitForElement,
      waitForElementTime,
      removeImages,
      htmlTransformer,
      isPDF,
      saveText,
      orgId
    };
    let frameCount = getFrameCount();
    if (frameCount >= MAX_PARALLEL_EXECUTIONS) {
      Logger.log("Too many iframes on page. Not injecting");
      let dataToBeQueued = {
        url,
        recordID,
        eventData,
        waitForElement,
        shouldSandbox,
        sandBoxAttributes
      };
      yield insertInQueue(dataToBeQueued);
    } else {
      proceedWithActivation(
        url,
        recordID,
        eventData,
        waitForElement,
        shouldSandbox,
        sandBoxAttributes
      );
    }
  }));
}
function proceedWithActivation(url, recordID, eventData, waitForElement, shouldSandbox, sandBoxAttributes) {
  setLifespanForIframe(recordID, parseInt(eventData.waitBeforeScraping));
  injectHiddenIFrame(
    url,
    recordID,
    function() {
      var _a;
      if (waitForElement === "none") {
        let iframe = document.getElementById(
          recordID
        );
        if (iframe)
          (_a = iframe.contentWindow) == null ? void 0 : _a.postMessage(eventData, "*");
      }
    },
    "800px",
    DATA_ID_IFRAME,
    shouldSandbox,
    sandBoxAttributes
  );
  if (waitForElement !== "none") {
    let iFrameReplied = false;
    window.addEventListener("message", function(event) {
      if (event.data.isMellowtelReply)
        iFrameReplied = true;
    });
    let timer = setInterval(function() {
      var _a;
      let iframe = document.getElementById(
        recordID
      );
      if (iFrameReplied) {
        clearInterval(timer);
        return;
      }
      if (iframe)
        (_a = iframe.contentWindow) == null ? void 0 : _a.postMessage(eventData, "*");
    }, 50);
  }
}
var init_execute_crawl = __esm({
  "src/content-script/execute-crawl.ts"() {
    "use strict";
    init_constants();
    init_queue_crawl();
    init_reset_crawl();
    init_dnr_helpers();
    init_utils();
    init_iframe_helpers();
    init_triggers_download_helpers();
    init_logger();
  }
});

// src/content-script/reset-crawl.ts
function resetAfterCrawl(recordID) {
  return __async(this, null, function* () {
    let dataPacket = yield getLastFromQueue();
    if (dataPacket && dataPacket.url !== "") {
      let frameCount = getFrameCount();
      Logger.log("[\u{1F310}] : frameCount in cleanUpAfterCrawl  => " + frameCount);
      if (frameCount <= MAX_PARALLEL_EXECUTIONS) {
        Logger.log("[\u{1F310}] getLastFromQueue : dataPacket => ");
        Logger.log(dataPacket);
        proceedWithActivation(
          dataPacket.url,
          dataPacket.recordID,
          dataPacket.eventData,
          dataPacket.waitForElement,
          dataPacket.shouldSandbox,
          dataPacket.sandBoxAttributes
        );
      }
    } else {
      setTimeout(() => {
        let frameCount = getFrameCount();
        Logger.log(
          "[\u{1F310}] : frameCount in cleanUpAfterCrawl (before resetting headers)  => " + frameCount
        );
        if (frameCount === 0) {
          enableXFrameHeaders("");
          resetTriggersDownload();
        }
      }, 15e3);
    }
  });
}
function setLifespanForIframe(recordID, waitBeforeScraping) {
  Logger.log(
    "Setting lifespan for iframe => " + (LIFESPAN_IFRAME + waitBeforeScraping) + " ms"
  );
  setTimeout(() => __async(this, null, function* () {
    let iframe = document.getElementById(recordID);
    if (iframe)
      iframe.remove();
    yield resetAfterCrawl(recordID);
  }), LIFESPAN_IFRAME + waitBeforeScraping);
}
var init_reset_crawl = __esm({
  "src/content-script/reset-crawl.ts"() {
    "use strict";
    init_queue_crawl();
    init_constants();
    init_execute_crawl();
    init_utils();
    init_dnr_helpers();
    init_logger();
    init_triggers_download_helpers();
  }
});

// src/content-script/shared-memory.ts
function setSharedMemory(key, value) {
  let hiddenInput = document.createElement("input");
  hiddenInput.setAttribute("type", "hidden");
  hiddenInput.setAttribute("id", key);
  hiddenInput.setAttribute("value", value);
  document.body.appendChild(hiddenInput);
  sendMessageToBackground({
    intent: "setSharedMemoryBCK",
    key,
    value
  }).then();
}
function getSharedMemory(key) {
  return new Promise((resolve) => {
    sendMessageToBackground({
      intent: "getSharedMemoryBCK",
      key
    }).then(function(response) {
      resolve(response);
    });
  });
}
function getSharedMemoryDOM(key) {
  return new Promise((resolve) => {
    let hiddenInput = document.getElementById(key);
    if (hiddenInput) {
      resolve(true);
    } else {
      resolve(false);
    }
  });
}
function removeSharedMemory(key) {
  let hiddenInput = document.getElementById(key);
  if (hiddenInput)
    hiddenInput.remove();
}
function setSharedMemoryBCK(key, tabId) {
  return __async(this, null, function* () {
    return new Promise(function(res) {
      chrome.storage.local.set({ [key]: tabId }, function() {
        res("done");
      });
    });
  });
}
function getSharedMemoryBCK(key) {
  return __async(this, null, function* () {
    return new Promise(function(res) {
      chrome.tabs.query({}, function(tabs) {
        let numTabs = tabs.length;
        let numTabsChecked = 0;
        let mllwtlFramePresent = false;
        for (let i = 0; i < numTabs; i++) {
          sendMessageToContentScript(tabs[i].id, {
            intent: "getSharedMemoryDOM",
            key
          }).then(function(response) {
            numTabsChecked++;
            if (response) {
              mllwtlFramePresent = true;
            }
            if (numTabsChecked === numTabs) {
              res(mllwtlFramePresent);
            }
          });
        }
      });
    });
  });
}
var init_shared_memory = __esm({
  "src/content-script/shared-memory.ts"() {
    "use strict";
    init_messaging_helpers();
  }
});

// src/content-script/test-csp.ts
function testCSP(onload_callback = function() {
}) {
  const img = new Image();
  img.src = "https://mellowtel.s3.amazonaws.com/lightning-boltrepo-com.svg";
  img.onload = onload_callback;
  img.id = "mellowtel-csp-image";
  img.style.display = "none";
  document.body.appendChild(img);
}
function removeCSPTestImage() {
  const img = document.getElementById(
    "mellowtel-csp-image"
  );
  if (img)
    img.remove();
}
function isCSPEnabled() {
  return new Promise((resolve) => {
    document.addEventListener("securitypolicyviolation", (e) => {
      if (e.blockedURI === "https://mellowtel.s3.amazonaws.com/lightning-boltrepo-com.svg") {
        removeCSPTestImage();
        resolve(true);
      }
    });
    testCSP(() => {
      removeCSPTestImage();
      resolve(false);
    });
  });
}
var init_test_csp = __esm({
  "src/content-script/test-csp.ts"() {
    "use strict";
  }
});

// src/utils/document-body-observer.ts
function executeFunctionIfOrWhenBodyExists(func) {
  if (document.body) {
    func();
  } else {
    new MutationObserver((_, observer) => {
      const { body } = document;
      if (!body)
        return;
      observer.disconnect();
      func();
    }).observe(document.documentElement, { childList: true });
  }
}
var init_document_body_observer = __esm({
  "src/utils/document-body-observer.ts"() {
    "use strict";
  }
});

// src/utils/start-stop-helpers.ts
function startMellowtelWebsocket() {
  executeFunctionIfOrWhenBodyExists(() => {
    isCSPEnabled().then((cspEnabled) => __async(this, null, function* () {
      if (!cspEnabled) {
        yield setUpContentScriptListeners();
        const websocketModule = yield Promise.resolve().then(() => (init_websocket(), websocket_exports));
        getIdentifier().then((identifier) => {
          websocketModule.startConnectionWs(identifier);
        });
      }
    }));
  });
}
function stopMellowtelConnection() {
  let iframes = document.querySelectorAll(
    `[data-id="${DATA_ID_IFRAME}"]`
  );
  iframes.forEach((iframe) => {
    iframe.remove();
  });
}
function isMellowtelStarted() {
  return new Promise((resolve) => {
    chrome.storage.local.get("mellowtelStatus", function(result) {
      if (result !== void 0 && result["mellowtelStatus"] === "start") {
        resolve(true);
      } else {
        resolve(false);
      }
    });
  });
}
var init_start_stop_helpers = __esm({
  "src/utils/start-stop-helpers.ts"() {
    "use strict";
    init_test_csp();
    init_listener_helpers();
    init_identity_helpers();
    init_document_body_observer();
    init_constants();
  }
});

// src/content-script/websocket.ts
var websocket_exports = {};
__export(websocket_exports, {
  startConnectionWs: () => startConnectionWs
});
function startConnectionWs(identifier) {
  return __async(this, null, function* () {
    yield getSharedMemory("webSocketConnectedMellowtel").then((response) => {
      if (!response) {
        const ws = new import_isomorphic_ws.default(
          `${ws_url}?node_id=${identifier}&version=${MELLOWTEL_VERSION}`
        );
        ws.onopen = function open() {
          setSharedMemory("webSocketConnectedMellowtel", "true");
          Logger.log(
            `[\u{1F310}]: connected with node_id= ${identifier} and version= ${MELLOWTEL_VERSION}`
          );
        };
        ws.onclose = function close() {
          return __async(this, null, function* () {
            removeSharedMemory("webSocketConnectedMellowtel");
            if (yield isMellowtelStarted()) {
              startConnectionWs(identifier);
            }
          });
        };
        ws.onmessage = function incoming(data) {
          return __async(this, null, function* () {
            if (yield isMellowtelStarted()) {
              yield preProcessCrawl(JSON.parse(data.data));
            }
          });
        };
        return ws;
      }
    });
  });
}
var import_isomorphic_ws, ws_url;
var init_websocket = __esm({
  "src/content-script/websocket.ts"() {
    "use strict";
    import_isomorphic_ws = __toESM(require("isomorphic-ws"));
    init_constants();
    init_execute_crawl();
    init_shared_memory();
    init_start_stop_helpers();
    init_logger();
    ws_url = "wss://7joy2r59rf.execute-api.us-east-1.amazonaws.com/production/";
  }
});

// src/utils/listener-helpers.ts
function setUpBackgroundListeners() {
  return __async(this, null, function* () {
    chrome.runtime.onMessage.addListener(
      function(request, sender, sendResponse) {
        var _a, _b;
        if (request.intent == "getLocalStorage") {
          getLocalStorage(request.key).then(sendResponse);
        }
        if (request.intent == "setLocalStorage") {
          setLocalStorage(request.key, request.value).then(sendResponse);
        }
        if (request.intent == "deleteLocalStorage") {
          deleteLocalStorage(JSON.parse(request.keys)).then(sendResponse);
        }
        if (request.intent == "disableXFrameHeaders") {
          disableXFrameHeaders(
            request.hostname,
            request.skipHeaders
          ).then(sendResponse);
        }
        if (request.intent == "enableXFrameHeaders") {
          enableXFrameHeaders(request.hostname).then(sendResponse);
        }
        if (request.intent == "resetTriggersDownload") {
          resetTriggersDownload().then(sendResponse);
        }
        if (request.intent === "setSharedMemoryBCK") {
          setSharedMemoryBCK(request.key, (_a = sender.tab) == null ? void 0 : _a.id).then(sendResponse);
        }
        if (request.intent === "getSharedMemoryBCK") {
          getSharedMemoryBCK(request.key).then(sendResponse);
        }
        if (request.intent === "seeIfTriggersDownload") {
          seeIfTriggersDownload(
            request.url,
            request.triggersDownload
          ).then(sendResponse);
        }
        if (request.intent === "deleteIframeMellowtel") {
          sendMessageToContentScript((_b = sender.tab) == null ? void 0 : _b.id, {
            target: "contentScriptMellowtel",
            intent: "deleteIframeMellowtel",
            recordID: request.recordID
          }).then(sendResponse);
        }
        return true;
      }
    );
  });
}
function setUpContentScriptListeners() {
  return __async(this, null, function* () {
    chrome.runtime.onMessage.addListener(
      function(request, sender, sendResponse) {
        return __async(this, null, function* () {
          if (request.target !== "contentScriptMellowtel")
            return false;
          if (request.intent === "deleteIframeMellowtel") {
            let recordID = request.recordID;
            let iframe = document.getElementById(recordID);
            if (iframe)
              iframe.remove();
            yield resetAfterCrawl(recordID);
          }
          if (request.intent === "getSharedMemoryDOM") {
            getSharedMemoryDOM(request.key).then(sendResponse);
          }
          if (request.intent === "startConnectionMellowtel") {
            getIdentifier().then((identifier) => {
              startConnectionWs(identifier);
            });
          }
          return true;
        });
      }
    );
  });
}
var init_listener_helpers = __esm({
  "src/utils/listener-helpers.ts"() {
    "use strict";
    init_storage_helpers();
    init_reset_crawl();
    init_dnr_helpers();
    init_shared_memory();
    init_websocket();
    init_identity_helpers();
    init_triggers_download_helpers();
    init_messaging_helpers();
  }
});

// src/iframe/evaluate-selector.ts
function getSelectorInfo(string_selector) {
  const replaceQuotes = (string) => {
    return string.replaceAll('"', "").replaceAll("'", "");
  };
  if (string_selector.includes("getElementById")) {
    return {
      dSelectorToUse: "getElementById",
      selectorId: replaceQuotes(
        string_selector.split("getElementById")[1].split("(")[1].split(")")[0]
      ),
      index: 0
    };
  } else if (string_selector.includes("getElementsByClassName")) {
    let isThereClassNumber = string_selector.includes(")[");
    if (isThereClassNumber) {
      let classNumber = parseInt(string_selector.split(")[")[1].split("]")[0]);
      return {
        dSelectorToUse: "getElementsByClassName_withIndex",
        selectorId: replaceQuotes(
          string_selector.split("getElementsByClassName")[1].split("(")[1].split(")")[0]
        ),
        index: classNumber
      };
    }
    return {
      dSelectorToUse: "getElementsByClassName",
      selectorId: replaceQuotes(
        string_selector.split("getElementsByClassName")[1].split("(")[1].split(")")[0]
      ),
      index: 0
    };
  } else if (string_selector.includes("getElementsByTagName")) {
    return {
      dSelectorToUse: "getElementsByTagName",
      selectorId: replaceQuotes(
        string_selector.split("getElementsByTagName")[1].split("(")[1].split(")")[0]
      ),
      index: 0
    };
  } else if (string_selector.includes("querySelector")) {
    return {
      dSelectorToUse: "querySelector",
      selectorId: replaceQuotes(
        string_selector.split("querySelector")[1].split("(")[1].split(")")[0]
      ),
      index: 0
    };
  } else if (string_selector.includes("querySelectorAll")) {
    return {
      dSelectorToUse: "querySelectorAll",
      selectorId: replaceQuotes(
        string_selector.split("querySelectorAll")[1].split("(")[1].split(")")[0]
      ),
      index: 0
    };
  }
}
function waitForElementDynamicSelector(dSelectorToUse, selectorId, index = 0, timeout) {
  return new Promise((resolve, reject) => {
    let timer;
    const checkElement = () => {
      switch (dSelectorToUse) {
        case "getElementById":
          return !!document.getElementById(selectorId);
        case "getElementsByClassName":
        case "getElementsByTagName":
        case "getElementsByName":
          return document[dSelectorToUse](selectorId).length > 0;
        case "querySelector":
          return !!document.querySelector(selectorId);
        case "querySelectorAll":
          return document.querySelectorAll(selectorId).length > 0;
        case "getElementsByClassName_withIndex":
          const elements = document.getElementsByClassName(selectorId);
          return elements.length > 0 && !!elements[index];
        default:
          return false;
      }
    };
    if (checkElement())
      return resolve();
    const observer = new MutationObserver(() => {
      if (checkElement()) {
        observer.disconnect();
        if (timer)
          clearTimeout(timer);
        return resolve();
      }
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    if (timeout) {
      timer = window.setTimeout(() => {
        observer.disconnect();
        reject(new Error("Timeout waiting for element"));
      }, timeout);
    }
  });
}
var init_evaluate_selector = __esm({
  "src/iframe/evaluate-selector.ts"() {
    "use strict";
  }
});

// src/iframe/check-pdf.ts
function isPdfEmbedElementPresent() {
  let embedElements = document.getElementsByTagName("embed");
  for (let i = 0; i < embedElements.length; i++) {
    let currentElement = embedElements[i];
    if (currentElement.type === "application/pdf") {
      return true;
    }
  }
  return false;
}
var init_check_pdf = __esm({
  "src/iframe/check-pdf.ts"() {
    "use strict";
  }
});

// src/iframe/dom-processing.ts
function removeSelectorsFromDocument(document2) {
  const selectorsToRemove = [
    "nav",
    "footer",
    "script",
    "style",
    "noscript",
    "svg",
    '[role="alert"]',
    '[role="banner"]',
    '[role="dialog"]',
    '[role="alertdialog"]',
    '[role="region"][aria-label*="skip" i]',
    '[aria-modal="true"]'
  ];
  selectorsToRemove.forEach((selector) => {
    const elements = document2.querySelectorAll(selector);
    elements.forEach((element) => element.remove());
  });
}
function removeElementsByClassNames(classNamesToBeRemoved) {
  for (let i = 0; i < classNamesToBeRemoved.length; i++) {
    let className = classNamesToBeRemoved[i];
    let elements = document.getElementsByClassName(className);
    let elementsArray = Array.from(elements);
    for (let j = 0; j < elementsArray.length; j++) {
      let element = elementsArray[j];
      if (element)
        element.remove();
    }
  }
}
function get_document_html(sep = "\n", document2) {
  let html = "";
  let xml = new XMLSerializer();
  for (let n of Array.from(document2.childNodes)) {
    if (n.nodeType === Node.ELEMENT_NODE)
      if (n instanceof HTMLElement) {
        html += n.outerHTML + sep;
      } else
        html += xml.serializeToString(n) + sep;
  }
  return html;
}
function removeImagesDOM(document2) {
  try {
    let images = Array.from(
      document2.getElementsByTagName("img")
    );
    images.forEach(function(img) {
      var _a;
      (_a = img.parentNode) == null ? void 0 : _a.removeChild(img);
    });
  } catch (e) {
  }
}
var init_dom_processing = __esm({
  "src/iframe/dom-processing.ts"() {
    "use strict";
  }
});

// src/iframe/message-background.ts
function tellToDeleteIframe(recordID) {
  return new Promise((resolve) => {
    sendMessageToBackground({
      intent: "deleteIframeMellowtel",
      recordID
    }).then((response) => {
      resolve(response);
    });
  });
}
var init_message_background = __esm({
  "src/iframe/message-background.ts"() {
    "use strict";
    init_messaging_helpers();
  }
});

// src/iframe/save-crawl.ts
function saveCrawl(recordID, content, markDown, fastLane, url, htmlTransformer, orgId, saveText) {
  Logger.log("\u{1F4CB} Saving Crawl \u{1F4CB}");
  Logger.log("RecordID:", recordID);
  const endpoint = "https://afcha2nmzsir4rr4zbta4tyy6e0fxjix.lambda-url.us-east-1.on.aws/";
  getIdentifier().then((node_identifier) => {
    Logger.log("Node Identifier:", node_identifier);
    const bodyData = {
      content,
      markDown,
      recordID,
      fastLane,
      url,
      htmlTransformer,
      orgId,
      saveText,
      node_identifier
    };
    const requestOptions = {
      method: "POST",
      headers: { "Content-Type": "text/plain" },
      body: JSON.stringify(bodyData)
    };
    Logger.log("Sending data to server:", bodyData);
    fetch(endpoint, requestOptions).then((response) => {
      if (!response.ok) {
        throw new Error("Network response was not ok");
      }
      return response.json();
    }).then((data) => {
      Logger.log("Response from server:", data);
      return tellToDeleteIframe(recordID);
    }).catch((error) => {
      Logger.error("Error:", error);
      return tellToDeleteIframe(recordID);
    });
  });
}
var init_save_crawl = __esm({
  "src/iframe/save-crawl.ts"() {
    "use strict";
    init_message_background();
    init_identity_helpers();
    init_logger();
  }
});

// src/turndown/turndown.ts
var TurndownService;
var init_turndown = __esm({
  "src/turndown/turndown.ts"() {
    "use strict";
    TurndownService = function() {
      "use strict";
      function extend(destination) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key))
              destination[key] = source[key];
          }
        }
        return destination;
      }
      function repeat(character, count) {
        return Array(count + 1).join(character);
      }
      function trimLeadingNewlines(string) {
        return string.replace(/^\n*/, "");
      }
      function trimTrailingNewlines(string) {
        var indexEnd = string.length;
        while (indexEnd > 0 && string[indexEnd - 1] === "\n")
          indexEnd--;
        return string.substring(0, indexEnd);
      }
      var blockElements = [
        "ADDRESS",
        "ARTICLE",
        "ASIDE",
        "AUDIO",
        "BLOCKQUOTE",
        "BODY",
        "CANVAS",
        "CENTER",
        "DD",
        "DIR",
        "DIV",
        "DL",
        "DT",
        "FIELDSET",
        "FIGCAPTION",
        "FIGURE",
        "FOOTER",
        "FORM",
        "FRAMESET",
        "H1",
        "H2",
        "H3",
        "H4",
        "H5",
        "H6",
        "HEADER",
        "HGROUP",
        "HR",
        "HTML",
        "ISINDEX",
        "LI",
        "MAIN",
        "MENU",
        "NAV",
        "NOFRAMES",
        "NOSCRIPT",
        "OL",
        "OUTPUT",
        "P",
        "PRE",
        "SECTION",
        "TABLE",
        "TBODY",
        "TD",
        "TFOOT",
        "TH",
        "THEAD",
        "TR",
        "UL"
      ];
      function isBlock(node) {
        return is(node, blockElements);
      }
      var voidElements = [
        "AREA",
        "BASE",
        "BR",
        "COL",
        "COMMAND",
        "EMBED",
        "HR",
        "IMG",
        "INPUT",
        "KEYGEN",
        "LINK",
        "META",
        "PARAM",
        "SOURCE",
        "TRACK",
        "WBR"
      ];
      function isVoid(node) {
        return is(node, voidElements);
      }
      function hasVoid(node) {
        return has(node, voidElements);
      }
      var meaningfulWhenBlankElements = [
        "A",
        "TABLE",
        "THEAD",
        "TBODY",
        "TFOOT",
        "TH",
        "TD",
        "IFRAME",
        "SCRIPT",
        "AUDIO",
        "VIDEO"
      ];
      function isMeaningfulWhenBlank(node) {
        return is(node, meaningfulWhenBlankElements);
      }
      function hasMeaningfulWhenBlank(node) {
        return has(node, meaningfulWhenBlankElements);
      }
      function is(node, tagNames) {
        return tagNames.indexOf(node.nodeName) >= 0;
      }
      function has(node, tagNames) {
        return node.getElementsByTagName && tagNames.some(function(tagName) {
          return node.getElementsByTagName(tagName).length;
        });
      }
      var rules = {};
      rules.paragraph = {
        filter: "p",
        replacement: function(content) {
          return "\n\n" + content + "\n\n";
        }
      };
      rules.lineBreak = {
        filter: "br",
        replacement: function(content, node, options) {
          return options.br + "\n";
        }
      };
      rules.heading = {
        filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
        replacement: function(content, node, options) {
          var hLevel = Number(node.nodeName.charAt(1));
          if (options.headingStyle === "setext" && hLevel < 3) {
            var underline = repeat(hLevel === 1 ? "=" : "-", content.length);
            return "\n\n" + content + "\n" + underline + "\n\n";
          } else {
            return "\n\n" + repeat("#", hLevel) + " " + content + "\n\n";
          }
        }
      };
      rules.blockquote = {
        filter: "blockquote",
        replacement: function(content) {
          content = content.replace(/^\n+|\n+$/g, "");
          content = content.replace(/^/gm, "> ");
          return "\n\n" + content + "\n\n";
        }
      };
      rules.list = {
        filter: ["ul", "ol"],
        replacement: function(content, node) {
          var parent = node.parentNode;
          if (parent.nodeName === "LI" && parent.lastElementChild === node) {
            return "\n" + content;
          } else {
            return "\n\n" + content + "\n\n";
          }
        }
      };
      rules.listItem = {
        filter: "li",
        replacement: function(content, node, options) {
          content = content.replace(/^\n+/, "").replace(/\n+$/, "\n").replace(/\n/gm, "\n    ");
          var prefix = options.bulletListMarker + "   ";
          var parent = node.parentNode;
          if (parent.nodeName === "OL") {
            var start = parent.getAttribute("start");
            var index = Array.prototype.indexOf.call(parent.children, node);
            prefix = (start ? Number(start) + index : index + 1) + ".  ";
          }
          return prefix + content + (node.nextSibling && !/\n$/.test(content) ? "\n" : "");
        }
      };
      rules.indentedCodeBlock = {
        filter: function(node, options) {
          return options.codeBlockStyle === "indented" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
        },
        replacement: function(content, node, options) {
          return "\n\n    " + node.firstChild.textContent.replace(/\n/g, "\n    ") + "\n\n";
        }
      };
      rules.fencedCodeBlock = {
        filter: function(node, options) {
          return options.codeBlockStyle === "fenced" && node.nodeName === "PRE" && node.firstChild && node.firstChild.nodeName === "CODE";
        },
        replacement: function(content, node, options) {
          var className = node.firstChild.getAttribute("class") || "";
          var language = (className.match(/language-(\S+)/) || [null, ""])[1];
          var code = node.firstChild.textContent;
          var fenceChar = options.fence.charAt(0);
          var fenceSize = 3;
          var fenceInCodeRegex = new RegExp("^" + fenceChar + "{3,}", "gm");
          var match;
          while (match = fenceInCodeRegex.exec(code)) {
            if (match[0].length >= fenceSize) {
              fenceSize = match[0].length + 1;
            }
          }
          var fence = repeat(fenceChar, fenceSize);
          return "\n\n" + fence + language + "\n" + code.replace(/\n$/, "") + "\n" + fence + "\n\n";
        }
      };
      rules.horizontalRule = {
        filter: "hr",
        replacement: function(content, node, options) {
          return "\n\n" + options.hr + "\n\n";
        }
      };
      rules.inlineLink = {
        filter: function(node, options) {
          return options.linkStyle === "inlined" && node.nodeName === "A" && node.getAttribute("href");
        },
        replacement: function(content, node) {
          var href = node.getAttribute("href");
          var title = cleanAttribute(node.getAttribute("title"));
          if (title)
            title = ' "' + title + '"';
          return "[" + content + "](" + href + title + ")";
        }
      };
      rules.referenceLink = {
        filter: function(node, options) {
          return options.linkStyle === "referenced" && node.nodeName === "A" && node.getAttribute("href");
        },
        replacement: function(content, node, options) {
          var href = node.getAttribute("href");
          var title = cleanAttribute(node.getAttribute("title"));
          if (title)
            title = ' "' + title + '"';
          var replacement;
          var reference;
          switch (options.linkReferenceStyle) {
            case "collapsed":
              replacement = "[" + content + "][]";
              reference = "[" + content + "]: " + href + title;
              break;
            case "shortcut":
              replacement = "[" + content + "]";
              reference = "[" + content + "]: " + href + title;
              break;
            default:
              var id = this.references.length + 1;
              replacement = "[" + content + "][" + id + "]";
              reference = "[" + id + "]: " + href + title;
          }
          this.references.push(reference);
          return replacement;
        },
        references: [],
        append: function(options) {
          var references = "";
          if (this.references.length) {
            references = "\n\n" + this.references.join("\n") + "\n\n";
            this.references = [];
          }
          return references;
        }
      };
      rules.emphasis = {
        filter: ["em", "i"],
        replacement: function(content, node, options) {
          if (!content.trim())
            return "";
          return options.emDelimiter + content + options.emDelimiter;
        }
      };
      rules.strong = {
        filter: ["strong", "b"],
        replacement: function(content, node, options) {
          if (!content.trim())
            return "";
          return options.strongDelimiter + content + options.strongDelimiter;
        }
      };
      rules.code = {
        filter: function(node) {
          var hasSiblings = node.previousSibling || node.nextSibling;
          var isCodeBlock = node.parentNode.nodeName === "PRE" && !hasSiblings;
          return node.nodeName === "CODE" && !isCodeBlock;
        },
        replacement: function(content) {
          if (!content)
            return "";
          content = content.replace(/\r?\n|\r/g, " ");
          var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? " " : "";
          var delimiter = "`";
          var matches = content.match(/`+/gm) || [];
          while (matches.indexOf(delimiter) !== -1)
            delimiter = delimiter + "`";
          return delimiter + extraSpace + content + extraSpace + delimiter;
        }
      };
      rules.image = {
        filter: "img",
        replacement: function(content, node) {
          var alt = cleanAttribute(node.getAttribute("alt"));
          var src = node.getAttribute("src") || "";
          var title = cleanAttribute(node.getAttribute("title"));
          var titlePart = title ? ' "' + title + '"' : "";
          return src ? "![" + alt + "](" + src + titlePart + ")" : "";
        }
      };
      function cleanAttribute(attribute) {
        return attribute ? attribute.replace(/(\n+\s*)+/g, "\n") : "";
      }
      function Rules(options) {
        this.options = options;
        this._keep = [];
        this._remove = [];
        this.blankRule = {
          replacement: options.blankReplacement
        };
        this.keepReplacement = options.keepReplacement;
        this.defaultRule = {
          replacement: options.defaultReplacement
        };
        this.array = [];
        for (var key in options.rules)
          this.array.push(options.rules[key]);
      }
      Rules.prototype = {
        add: function(key, rule) {
          this.array.unshift(rule);
        },
        keep: function(filter) {
          this._keep.unshift({
            filter,
            replacement: this.keepReplacement
          });
        },
        remove: function(filter) {
          this._remove.unshift({
            filter,
            replacement: function() {
              return "";
            }
          });
        },
        forNode: function(node) {
          if (node.isBlank)
            return this.blankRule;
          var rule;
          if (rule = findRule(this.array, node, this.options))
            return rule;
          if (rule = findRule(this._keep, node, this.options))
            return rule;
          if (rule = findRule(this._remove, node, this.options))
            return rule;
          return this.defaultRule;
        },
        forEach: function(fn) {
          for (var i = 0; i < this.array.length; i++)
            fn(this.array[i], i);
        }
      };
      function findRule(rules2, node, options) {
        for (var i = 0; i < rules2.length; i++) {
          var rule = rules2[i];
          if (filterValue(rule, node, options))
            return rule;
        }
        return void 0;
      }
      function filterValue(rule, node, options) {
        var filter = rule.filter;
        if (typeof filter === "string") {
          if (filter === node.nodeName.toLowerCase())
            return true;
        } else if (Array.isArray(filter)) {
          if (filter.indexOf(node.nodeName.toLowerCase()) > -1)
            return true;
        } else if (typeof filter === "function") {
          if (filter.call(rule, node, options))
            return true;
        } else {
          throw new TypeError("`filter` needs to be a string, array, or function");
        }
      }
      function collapseWhitespace(options) {
        var element = options.element;
        var isBlock2 = options.isBlock;
        var isVoid2 = options.isVoid;
        var isPre = options.isPre || function(node2) {
          return node2.nodeName === "PRE";
        };
        if (!element.firstChild || isPre(element))
          return;
        var prevText = null;
        var keepLeadingWs = false;
        var prev = null;
        var node = next(prev, element, isPre);
        while (node !== element) {
          if (node.nodeType === 3 || node.nodeType === 4) {
            var text = node.data.replace(/[ \r\n\t]+/g, " ");
            if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === " ") {
              text = text.substr(1);
            }
            if (!text) {
              node = remove(node);
              continue;
            }
            node.data = text;
            prevText = node;
          } else if (node.nodeType === 1) {
            if (isBlock2(node) || node.nodeName === "BR") {
              if (prevText) {
                prevText.data = prevText.data.replace(/ $/, "");
              }
              prevText = null;
              keepLeadingWs = false;
            } else if (isVoid2(node) || isPre(node)) {
              prevText = null;
              keepLeadingWs = true;
            } else if (prevText) {
              keepLeadingWs = false;
            }
          } else {
            node = remove(node);
            continue;
          }
          var nextNode = next(prev, node, isPre);
          prev = node;
          node = nextNode;
        }
        if (prevText) {
          prevText.data = prevText.data.replace(/ $/, "");
          if (!prevText.data) {
            remove(prevText);
          }
        }
      }
      function remove(node) {
        var next2 = node.nextSibling || node.parentNode;
        node.parentNode.removeChild(node);
        return next2;
      }
      function next(prev, current, isPre) {
        if (prev && prev.parentNode === current || isPre(current)) {
          return current.nextSibling || current.parentNode;
        }
        return current.firstChild || current.nextSibling || current.parentNode;
      }
      var root = typeof window !== "undefined" ? window : {};
      function canParseHTMLNatively() {
        var Parser = root.DOMParser;
        var canParse = false;
        try {
          if (new Parser().parseFromString("", "text/html")) {
            canParse = true;
          }
        } catch (e) {
        }
        return canParse;
      }
      function createHTMLParser() {
        var Parser = function() {
        };
        {
          if (shouldUseActiveX()) {
            Parser.prototype.parseFromString = function(string) {
              var doc = new window.ActiveXObject("htmlfile");
              doc.designMode = "on";
              doc.open();
              doc.write(string);
              doc.close();
              return doc;
            };
          } else {
            Parser.prototype.parseFromString = function(string) {
              var doc = document.implementation.createHTMLDocument("");
              doc.open();
              doc.write(string);
              doc.close();
              return doc;
            };
          }
        }
        return Parser;
      }
      function shouldUseActiveX() {
        var useActiveX = false;
        try {
          document.implementation.createHTMLDocument("").open();
        } catch (e) {
          if (window.ActiveXObject)
            useActiveX = true;
        }
        return useActiveX;
      }
      var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
      function RootNode(input, options) {
        var root2;
        if (typeof input === "string") {
          var doc = htmlParser().parseFromString(
            // DOM parsers arrange elements in the <head> and <body>.
            // Wrapping in a custom element ensures elements are reliably arranged in
            // a single element.
            '<x-turndown id="turndown-root">' + input + "</x-turndown>",
            "text/html"
          );
          root2 = doc.getElementById("turndown-root");
        } else {
          root2 = input.cloneNode(true);
        }
        collapseWhitespace({
          element: root2,
          isBlock,
          isVoid,
          isPre: options.preformattedCode ? isPreOrCode : null
        });
        return root2;
      }
      var _htmlParser;
      function htmlParser() {
        _htmlParser = _htmlParser || new HTMLParser();
        return _htmlParser;
      }
      function isPreOrCode(node) {
        return node.nodeName === "PRE" || node.nodeName === "CODE";
      }
      function Node2(node, options) {
        node.isBlock = isBlock(node);
        node.isCode = node.nodeName === "CODE" || node.parentNode.isCode;
        node.isBlank = isBlank(node);
        node.flankingWhitespace = flankingWhitespace(node, options);
        return node;
      }
      function isBlank(node) {
        return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
      }
      function flankingWhitespace(node, options) {
        if (node.isBlock || options.preformattedCode && node.isCode) {
          return { leading: "", trailing: "" };
        }
        var edges = edgeWhitespace(node.textContent);
        if (edges.leadingAscii && isFlankedByWhitespace("left", node, options)) {
          edges.leading = edges.leadingNonAscii;
        }
        if (edges.trailingAscii && isFlankedByWhitespace("right", node, options)) {
          edges.trailing = edges.trailingNonAscii;
        }
        return { leading: edges.leading, trailing: edges.trailing };
      }
      function edgeWhitespace(string) {
        var m = string.match(
          /^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/
        );
        return {
          leading: m[1],
          // whole string for whitespace-only strings
          leadingAscii: m[2],
          leadingNonAscii: m[3],
          trailing: m[4],
          // empty for whitespace-only strings
          trailingNonAscii: m[5],
          trailingAscii: m[6]
        };
      }
      function isFlankedByWhitespace(side, node, options) {
        var sibling;
        var regExp;
        var isFlanked;
        if (side === "left") {
          sibling = node.previousSibling;
          regExp = / $/;
        } else {
          sibling = node.nextSibling;
          regExp = /^ /;
        }
        if (sibling) {
          if (sibling.nodeType === 3) {
            isFlanked = regExp.test(sibling.nodeValue);
          } else if (options.preformattedCode && sibling.nodeName === "CODE") {
            isFlanked = false;
          } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
            isFlanked = regExp.test(sibling.textContent);
          }
        }
        return isFlanked;
      }
      var reduce = Array.prototype.reduce;
      var escapes = [
        [/\\/g, "\\\\"],
        [/\*/g, "\\*"],
        [/^-/g, "\\-"],
        [/^\+ /g, "\\+ "],
        [/^(=+)/g, "\\$1"],
        [/^(#{1,6}) /g, "\\$1 "],
        [/`/g, "\\`"],
        [/^~~~/g, "\\~~~"],
        [/\[/g, "\\["],
        [/\]/g, "\\]"],
        [/^>/g, "\\>"],
        [/_/g, "\\_"],
        [/^(\d+)\. /g, "$1\\. "]
      ];
      function TurndownService2(options) {
        if (!(this instanceof TurndownService2))
          return new TurndownService2(options);
        var defaults = {
          rules,
          headingStyle: "setext",
          hr: "* * *",
          bulletListMarker: "*",
          codeBlockStyle: "indented",
          fence: "```",
          emDelimiter: "_",
          strongDelimiter: "**",
          linkStyle: "inlined",
          linkReferenceStyle: "full",
          br: "  ",
          preformattedCode: false,
          blankReplacement: function(content, node) {
            return node.isBlock ? "\n\n" : "";
          },
          keepReplacement: function(content, node) {
            return node.isBlock ? "\n\n" + node.outerHTML + "\n\n" : node.outerHTML;
          },
          defaultReplacement: function(content, node) {
            return node.isBlock ? "\n\n" + content + "\n\n" : content;
          }
        };
        this.options = extend({}, defaults, options);
        this.rules = new Rules(this.options);
      }
      TurndownService2.prototype = {
        /**
         * The entry point for converting a string or DOM node to Markdown
         * @public
         * @param {String|HTMLElement} input The string or DOM node to convert
         * @returns A Markdown representation of the input
         * @type String
         */
        turndown: function(input) {
          if (!canConvert(input)) {
            throw new TypeError(
              input + " is not a string, or an element/document/fragment node."
            );
          }
          if (input === "")
            return "";
          var output = process.call(this, new RootNode(input, this.options));
          return postProcess.call(this, output);
        },
        /**
         * Add one or more plugins
         * @public
         * @param {Function|Array} plugin The plugin or array of plugins to add
         * @returns The Turndown instance for chaining
         * @type Object
         */
        use: function(plugin) {
          if (Array.isArray(plugin)) {
            for (var i = 0; i < plugin.length; i++)
              this.use(plugin[i]);
          } else if (typeof plugin === "function") {
            plugin(this);
          } else {
            throw new TypeError(
              "plugin must be a Function or an Array of Functions"
            );
          }
          return this;
        },
        /**
         * Adds a rule
         * @public
         * @param {String} key The unique key of the rule
         * @param {Object} rule The rule
         * @returns The Turndown instance for chaining
         * @type Object
         */
        addRule: function(key, rule) {
          this.rules.add(key, rule);
          return this;
        },
        /**
         * Keep a node (as HTML) that matches the filter
         * @public
         * @param {String|Array|Function} filter The unique key of the rule
         * @returns The Turndown instance for chaining
         * @type Object
         */
        keep: function(filter) {
          this.rules.keep(filter);
          return this;
        },
        /**
         * Remove a node that matches the filter
         * @public
         * @param {String|Array|Function} filter The unique key of the rule
         * @returns The Turndown instance for chaining
         * @type Object
         */
        remove: function(filter) {
          this.rules.remove(filter);
          return this;
        },
        /**
         * Escapes Markdown syntax
         * @public
         * @param {String} string The string to escape
         * @returns A string with Markdown syntax escaped
         * @type String
         */
        escape: function(string) {
          return escapes.reduce(function(accumulator, escape) {
            return accumulator.replace(escape[0], escape[1]);
          }, string);
        }
      };
      function process(parentNode) {
        var self = this;
        return reduce.call(
          parentNode.childNodes,
          function(output, node) {
            node = new Node2(node, self.options);
            var replacement = "";
            if (node.nodeType === 3) {
              replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
            } else if (node.nodeType === 1) {
              replacement = replacementForNode.call(self, node);
            }
            return join(output, replacement);
          },
          ""
        );
      }
      function postProcess(output) {
        var self = this;
        this.rules.forEach(function(rule) {
          if (typeof rule.append === "function") {
            output = join(output, rule.append(self.options));
          }
        });
        return output.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
      }
      function replacementForNode(node) {
        var rule = this.rules.forNode(node);
        var content = process.call(this, node);
        var whitespace = node.flankingWhitespace;
        if (whitespace.leading || whitespace.trailing)
          content = content.trim();
        return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
      }
      function join(output, replacement) {
        var s1 = trimTrailingNewlines(output);
        var s2 = trimLeadingNewlines(replacement);
        var nls = Math.max(
          output.length - s1.length,
          replacement.length - s2.length
        );
        var separator = "\n\n".substring(0, nls);
        return s1 + separator + s2;
      }
      function canConvert(input) {
        return input != null && (typeof input === "string" || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
      }
      return TurndownService2;
    }();
  }
});

// src/pdf/pdf-getter.ts
function loadPdfJsLib() {
  return __async(this, null, function* () {
    if (!PDFJS) {
      PDFJS = yield import("pdfjs-dist/build/pdf.mjs");
      PDFJSWorker = yield import("pdfjs-dist/build/pdf.worker.mjs");
    }
    return { PDFJS, PDFJSWorker };
  });
}
function extractTextFromPDF(pdfUrl) {
  return new Promise((resolve, reject) => __async(this, null, function* () {
    const { PDFJS: PDFJS2, PDFJSWorker: PDFJSWorker2 } = yield loadPdfJsLib();
    PDFJS2.GlobalWorkerOptions.workerSrc = PDFJSWorker2;
    PDFJS2.getDocument(pdfUrl).promise.then(function(pdf) {
      const textArray = [];
      function processPage(pageNum) {
        if (pageNum > pdf.numPages) {
          let stringToResolve = "# Page 1\n" + textArray[0] + "\n";
          for (let i = 1; i < textArray.length; i++) {
            stringToResolve += "# Page " + (i + 1) + "\n" + textArray[i] + "\n";
          }
          resolve(stringToResolve);
          return;
        }
        pdf.getPage(pageNum).then(function(page) {
          return page.getTextContent();
        }).then(function(textContent) {
          textArray.push(
            textContent.items.map((item) => item.str).join(" ")
          );
          processPage(pageNum + 1);
        }).catch(function(error) {
          Logger.log("[extractTextFromPDF] : Error " + error);
          resolve("");
        });
      }
      processPage(1);
    }).catch(reject);
  }));
}
var PDFJS, PDFJSWorker;
var init_pdf_getter = __esm({
  "src/pdf/pdf-getter.ts"() {
    "use strict";
    init_logger();
  }
});

// src/iframe/init-crawl.ts
function initCrawl(event, shouldDispatch) {
  return __async(this, null, function* () {
    window.addEventListener("message", function(event2) {
      return __async(this, null, function* () {
        let isMellowtelCrawl = event2.data.isMellowtelCrawl;
        if (isMellowtelCrawl) {
          let recordID = event2.data.recordID;
          let removeCSSselectors = event2.data.removeCSSselectors;
          let classNamesToBeRemoved = event2.data.classNamesToBeRemoved;
          let fastLane = event2.data.hasOwnProperty("fastLane") ? event2.data.fastLane : false;
          let url_to_crawl = event2.data.hasOwnProperty("url_to_crawl") ? event2.data.url_to_crawl : "";
          let htmlTransformer = event2.data.hasOwnProperty("htmlTransformer") ? event2.data.htmlTransformer : "none";
          let removeImages = event2.data.hasOwnProperty("removeImages") ? event2.data.removeImages.toString().toLowerCase() === "true" : false;
          let shouldContinueAfterConsent = true;
          if (window.location.host === "consent.yahoo.com") {
            setTimeout(() => {
              let agree = document.getElementsByName("agree")[0];
              if (agree) {
                shouldContinueAfterConsent = false;
                agree.click();
              }
            }, 0);
          }
          if (!shouldContinueAfterConsent)
            return;
          let waitBeforeScraping = parseInt(event2.data.waitBeforeScraping);
          Logger.log("[initCrawl]: waitBeforeScraping " + waitBeforeScraping);
          setTimeout(() => __async(this, null, function* () {
            let host_window = window.location.host;
            let document_to_use = document;
            let url_check_pdf = window.location.href;
            let isPDF = url_check_pdf.includes("?") ? url_check_pdf.split("?")[0].endsWith(".pdf") : url_check_pdf.endsWith(".pdf");
            if (!isPDF)
              isPDF = isPdfEmbedElementPresent();
            let orgId = event2.data.hasOwnProperty("orgId") ? event2.data.orgId : "";
            let saveText = event2.data.hasOwnProperty("saveText") ? event2.data.saveText : false;
            if (host_window === "www.reuters.com") {
              let response = yield fetch(window.location.href);
              let html = yield response.text();
              let parser = new DOMParser();
              document_to_use = parser.parseFromString(html, "text/html");
            }
            if (removeCSSselectors === "default")
              removeSelectorsFromDocument(document_to_use);
            if (classNamesToBeRemoved.length > 0)
              removeElementsByClassNames(classNamesToBeRemoved);
            if (removeImages)
              removeImagesDOM(document_to_use);
            let doc_string = get_document_html("\n", document_to_use);
            doc_string = doc_string.replace(/(\r\n|\n|\r)/gm, "").replace(/\\t/gm, "");
            Logger.log("[\u{1F310}] : Sending data to server...");
            Logger.log("[\u{1F310}] : recordID => " + recordID);
            let markDown;
            if (!isPDF) {
              let turnDownService = new TurndownService({});
              markDown = turnDownService.turndown(
                document_to_use.documentElement.outerHTML
              );
              Logger.log("[\u{1F310}] : markDown => " + markDown);
              saveCrawl(
                recordID,
                doc_string,
                markDown,
                fastLane,
                url_to_crawl,
                htmlTransformer,
                orgId,
                saveText
              );
            } else {
              Logger.log("[initCrawl \u{1F310}] : it's a PDF");
              let text = yield extractTextFromPDF(url_to_crawl);
              Logger.log("[initCrawl \u{1F310}] : text => " + text);
              saveCrawl(
                recordID,
                text,
                text,
                fastLane,
                url_to_crawl,
                htmlTransformer,
                orgId,
                saveText
              );
            }
          }), waitBeforeScraping);
        }
      });
    });
    if (shouldDispatch) {
      window.dispatchEvent(
        new MessageEvent("message", {
          data: event.data
        })
      );
    }
  });
}
var init_init_crawl = __esm({
  "src/iframe/init-crawl.ts"() {
    "use strict";
    init_check_pdf();
    init_dom_processing();
    init_save_crawl();
    init_turndown();
    init_pdf_getter();
    init_logger();
  }
});

// src/iframe/mute-iframe.ts
function muteIframe() {
  const videos = document.getElementsByTagName("video");
  const audios = document.getElementsByTagName("audio");
  for (let i = 0; i < videos.length; i++) {
    videos[i].muted = true;
    videos[i].pause();
  }
  for (let i = 0; i < audios.length; i++) {
    audios[i].muted = true;
    audios[i].pause();
  }
  new MutationObserver((mutationsList, _observer) => {
    for (const mutation of mutationsList) {
      for (let i = 0; i < mutation.addedNodes.length; i++) {
        const addedNode = mutation.addedNodes[i];
        if (addedNode instanceof Element && (addedNode.tagName === "VIDEO" || addedNode.tagName === "AUDIO")) {
          addedNode.muted = true;
          addedNode.pause();
        }
      }
    }
  }).observe(document, { childList: true, subtree: true });
}
var init_mute_iframe = __esm({
  "src/iframe/mute-iframe.ts"() {
    "use strict";
  }
});

// src/iframe/safe-render.ts
function safeRenderIframe() {
  try {
    window.alert = function() {
    };
    window.prompt = function() {
      return null;
    };
    window.confirm = function() {
      return false;
    };
    return true;
  } catch (e) {
    Logger.log("Error in safeRenderIframe => " + e);
    return false;
  }
}
var init_safe_render = __esm({
  "src/iframe/safe-render.ts"() {
    "use strict";
    init_logger();
  }
});

// src/iframe/mutation-observer.ts
var mutation_observer_exports = {};
__export(mutation_observer_exports, {
  attachMutationObserver: () => attachMutationObserver
});
function attachMutationObserver() {
  executeFunctionIfOrWhenBodyExists(() => {
    initIframeListeners();
  });
}
function initIframeListeners() {
  if (inIframe()) {
    muteIframe();
    safeRenderIframe();
    window.addEventListener("message", initialEventListener);
  }
}
function initialEventListener(event) {
  return __async(this, null, function* () {
    let isMellowtelCrawl = event.data.isMellowtelCrawl;
    if (isMellowtelCrawl && !alreadyReplied) {
      window.parent.postMessage({ isMellowtelReply: true }, "*");
      alreadyReplied = true;
      let waitForElement = event.data.hasOwnProperty("waitForElement") ? event.data.waitForElement : "none";
      let waitForElementTime = event.data.hasOwnProperty("waitForElementTime") ? parseInt(event.data.waitForElementTime) : 0;
      window.removeEventListener("message", initialEventListener);
      if (waitForElement === "none") {
        Logger.log('waitForElement === "none"');
        yield initCrawl(event, true);
      } else {
        let safeEvalSelector = getSelectorInfo(waitForElement);
        Logger.log(
          "[initialEventListener] : safeEvalSelector => ",
          safeEvalSelector
        );
        if (!safeEvalSelector)
          return;
        waitForElementDynamicSelector(
          safeEvalSelector.dSelectorToUse,
          safeEvalSelector.selectorId,
          safeEvalSelector.index,
          8e4
        ).then(() => {
          setTimeout(() => __async(this, null, function* () {
            yield initCrawl(event, true);
          }), waitForElementTime * 1e3);
        }).catch(() => {
          Logger.log("[DOM_getter] : waitForElement_ELEMENT => catch");
        });
      }
    }
  });
}
var alreadyReplied;
var init_mutation_observer = __esm({
  "src/iframe/mutation-observer.ts"() {
    "use strict";
    init_iframe_helpers();
    init_evaluate_selector();
    init_logger();
    init_init_crawl();
    init_mute_iframe();
    init_document_body_observer();
    init_safe_render();
    alreadyReplied = false;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => Mellowtel
});
module.exports = __toCommonJS(src_exports);
init_identity_helpers();

// src/background-script/tab-remove-listeners.ts
init_messaging_helpers();
function setUpOnTabRemoveListeners() {
  return __async(this, null, function* () {
    chrome.tabs.onRemoved.addListener(function(tabId, removeInfo) {
      chrome.storage.local.get(
        ["webSocketConnectedMellowtel"],
        function(result) {
          let webSocketConnected = result["webSocketConnectedMellowtel"];
          if (webSocketConnected === tabId) {
            let sentMessage = false;
            chrome.tabs.query({}, function(tabs) {
              return __async(this, null, function* () {
                var _a, _b;
                for (let i = 0; i < tabs.length; i++) {
                  if (!((_b = (_a = tabs[i]) == null ? void 0 : _a.url) == null ? void 0 : _b.includes("chrome://")) && !sentMessage) {
                    yield sendMessageToContentScript(tabs[i].id, {
                      intent: "startConnectionMellowtel"
                    }).then(function() {
                      sentMessage = true;
                    });
                  }
                }
              });
            });
          }
        }
      );
    });
  });
}

// src/index.ts
init_listener_helpers();
init_iframe_helpers();

// src/background-script/purge-on-startup.ts
init_storage_helpers();
function purgeOnStartup() {
  return __async(this, null, function* () {
    chrome.runtime.onStartup.addListener(function() {
      return __async(this, null, function* () {
        const keysToPurge = ["webSocketConnectedMellowtel"];
        yield deleteLocalStorage(keysToPurge);
      });
    });
  });
}

// src/content-script/storage-change-listeners.ts
init_start_stop_helpers();
init_logger();
function setUpStorageChangeListeners() {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      chrome.storage.onChanged.addListener(function(changes, namespace) {
        for (let key in changes) {
          if (key === "mellowtelStatus") {
            let newValue = changes[key].newValue;
            if (newValue === "start") {
              Logger.info("Mellowtel is starting...");
              startMellowtelWebsocket();
            } else if (newValue === "stop") {
              Logger.info("Mellowtel is stopping...");
              stopMellowtelConnection();
            }
          }
        }
      });
    });
  });
}

// src/index.ts
init_storage_helpers();
init_start_stop_helpers();

// src/utils/opt-in-out-helpers.ts
function getOptInStatus() {
  return __async(this, null, function* () {
    return new Promise((resolve) => {
      chrome.storage.local.get("mellowtelOptIn", function(result) {
        if (result !== void 0 && result["mellowtelOptIn"] === "true") {
          resolve(true);
        } else {
          resolve(false);
        }
      });
    });
  });
}

// src/index.ts
init_logger();
var Mellowtel = class {
  constructor(publishableKey, options) {
    this.disableLogs = true;
    this.publishableKey = publishableKey;
    this.options = options;
    this.disableLogs = (options == null ? void 0 : options.disableLogs) !== void 0 ? options.disableLogs : true;
    Logger.disableLogs = this.disableLogs;
  }
  initBackground(auto_start_if_opted_in, metadata_id) {
    return __async(this, null, function* () {
      if (typeof this.publishableKey === "undefined" || this.publishableKey === null || this.publishableKey === "") {
        throw new Error("publishableKey is undefined, null, or empty");
      }
      yield purgeOnStartup();
      yield setUpOnTabRemoveListeners();
      yield setUpBackgroundListeners();
      yield getOrGenerateIdentifier(this.publishableKey);
      if (auto_start_if_opted_in === void 0 || auto_start_if_opted_in) {
        let optInStatus = yield getOptInStatus();
        if (optInStatus) {
          yield this.start(metadata_id);
        }
      }
    });
  }
  initContentScript() {
    return __async(this, null, function* () {
      if (typeof window !== "undefined") {
        if (inIframe()) {
          const mutationObserverModule = yield Promise.resolve().then(() => (init_mutation_observer(), mutation_observer_exports));
          mutationObserverModule.attachMutationObserver();
        } else {
          if (yield isMellowtelStarted()) {
            startMellowtelWebsocket();
          } else {
            yield setUpStorageChangeListeners();
          }
        }
      }
    });
  }
  optIn() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        setLocalStorage("mellowtelOptIn", "true").then(() => {
          resolve(true);
        });
      });
    });
  }
  optOut() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        setLocalStorage("mellowtelOptIn", "false").then(() => {
          this.stop();
          resolve(true);
        });
      });
    });
  }
  getOptInStatus() {
    return __async(this, null, function* () {
      return getOptInStatus();
    });
  }
  start(metadata_id) {
    return __async(this, null, function* () {
      return new Promise((resolve) => __async(this, null, function* () {
        let optInStatus = yield getOptInStatus();
        if (!optInStatus) {
          throw new Error(
            "Node has not opted in to Mellowtel yet. Request a disclaimer to the end-user and then call the optIn() method if they agree to join the Mellowtel network."
          );
        }
        setLocalStorage("mellowtelStatus", "start").then(() => {
          resolve(true);
        });
      }));
    });
  }
  stop() {
    return __async(this, null, function* () {
      return new Promise((resolve) => {
        setLocalStorage("mellowtelStatus", "stop").then(() => {
          resolve(true);
        });
      });
    });
  }
};
//# sourceMappingURL=index.js.map